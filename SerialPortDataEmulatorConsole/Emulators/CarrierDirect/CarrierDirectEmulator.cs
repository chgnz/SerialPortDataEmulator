using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Ports;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SerialPortDataEmulatorConsole.SerialProtocols
{
    class CarrierDirectEmulator : ISerialEmulator
    {
        private SerialPort Port;
        private CarrierDirectMessage RxMsg = new CarrierDirectMessage();
        
        public void Init(SerialPort port)
        {
            this.Port = port;
            this.Port.StopBits = StopBits.One;
            this.Port.BaudRate = GetBaudrate();
            this.Port.Open();

            Console.WriteLine($"CarrierDirectProtocol Advanced Emulator Initialized. {port.PortName}, Baudrate: {GetBaudrate()}");
        }

        public void Trigger()
        {
            if (!Port.IsOpen)
            {
                Console.WriteLine($"CarrierDirectProtocol Port closed");
                return;
            }

            WaitRequest();

        }

        static int total_requests = 0;
        bool WaitRequest()
        {
            TimeSpan maxDuration = TimeSpan.FromMilliseconds(100);
            Stopwatch sw = Stopwatch.StartNew();

            while (RxMsg.GetRequiredSize() > 0 && 
                    Port.BytesToRead >= RxMsg.GetRequiredSize() && 
                    sw.Elapsed < maxDuration)
            {
                    
                byte[] buffer = new byte[RxMsg.GetRequiredSize()];
                Port.Read(buffer, 0, RxMsg.GetRequiredSize());
                
                if (RxMsg.Receive(buffer))
                {
                    Console.WriteLine($"RxMsg.Received. command: {RxMsg.Data.Header.CommandId}, {total_requests++}");

                    HandleRequest();
                    RxMsg.Reset();
                    return true;
                }
            }

            return false;
        }

        private void HandleRequest()
        {
            var data_without_crc = GenerateResponseWithoutCRC(RxMsg.Data.Header.CommandId);

            if (data_without_crc == null)
            {
                Console.WriteLine("no response generated");
                return;
            }

            // calculate crc
            byte crc = 0;

            for (int i = 0; i < data_without_crc.Length; i++)
            {
                crc += data_without_crc[i];
            }

            byte[] response = new byte[data_without_crc.Length + 1];
            System.Buffer.BlockCopy(data_without_crc, 0, response, 0, data_without_crc.Length);
            response[data_without_crc.Length] = crc;

            SendResponse(response);
        }

        protected virtual byte[] GenerateResponseWithoutCRC(byte command)
        {
            switch (command)
            {
                /*
                 * // idle mode
                case 0x01:
                    return new byte[] { 0x86, 0x03, 0x81, 0xaa, 0x63, 0x06, 0x07, 0x00, 0x00, 0xff, 0x02, 0x00};
                case 0x08:
                    return new byte[] { 0x86, 0x03, 0x88, 0xaa, 0x63, 0x0e, 0xdc, 0x02, 0xd5, 0x01, 0x05, 0x02, 0x42, 0x01, 0x62, 0x00, 0xff, 0x7f, 0xff, 0x7f };
                case 0x07:
                    return new byte[] { 0x86, 0x03, 0x87, 0xaa, 0x63, 0x06, 0x40, 0x02, 0x80, 0xfd, 0xff, 0x7f };
                case 0x0a:
                    return new byte[] { 0x86, 0x03, 0x8a, 0xaa, 0x63, 0x08, 0x9c, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };
                case 0x0b:
                    return new byte[] { 0x86, 0x03, 0x8b, 0xaa, 0x63, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00 };
                case 0x02:
                    return new byte[] { 0x86, 0x03, 0x82, 0xaa, 0x63, 0x01, 0x00 };
                */

                case 0x01:
                    // status
                    return new byte[] { 0x86, 0x03, 0x81, 0xaa, 0x63, 0x06, 0x03, 0x01, 0x02, 0xff, 0x0a, 0x00};
                case 0x08:
                    // temperature
                    return new byte[] { 0x86, 0x03, 0x88, 0xaa, 0x63, 0x0e, 0xe0, GetUInt8Random(), 0xe1, GetUInt8Random(), 0x0e, 0x02, GetUInt8Random(), 0x01, 0x84, GetUInt8Random(), 0xff, 0x7f, 0xff, 0x7f};
                case 0x07:
                    // setpoint
                    return new byte[] { 0x86, 0x03, 0x87, 0xaa, 0x63, 0x06, 0x40, 0x02, 0x80, 0xfd, 0xff, 0x7f};
                case 0x0a:
                    // engine
                    return new byte[] { 0x86, 0x03, 0x8a, 0xaa, 0x63, 0x08, 0xcb, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00};
                case 0x0b:
                    // msg hours
                    return new byte[] { 0x86, 0x03, 0x8b, 0xaa, 0x63, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00};
                case 0x02:
                    // alarms
                    return new byte[] { 0x86, 0x03, 0x82, 0xaa, 0x63, 0x01, 0x00};

                case 0x18:
                    // pretrip, nav reāli dati!!
                    return new byte[] { 0x86, 0x03, 0x98, 0xaa, 0x63, 0x05, 0x55, 0x55, 0x55, 0x55, 0x55 };




            /*
        //case 0x01: return new byte[] { 0x86, 0x03, 0x81, 0xaa, 0x63, 0x06, 0x03, 0x02, 0xff, 0xff, 0x1a, 0x00 };
        case 0x01: return new byte[] { 0x86, 0x03, 0x81, 0xaa, 0x63, 0x06, 0x03, 0x02, 0xff, 0xff, 0x1a, 0x00 };
        case 0x02: return new byte[] { 0x86, 0x03, 0x82, 0xaa, 0x63, 0x01, 0x00 };
        case 0x04: return new byte[] { 0x86, 0x03, 0x84, 0xaa, 0x63, 0x0b, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00 };
        case 0x05: return new byte[] { 0x86, 0x03, 0x85, 0xaa, 0x63, 0x0b, 0x52, 0x43, 0x34, 0x34, 0x36, 0x31, 0x34, 0x37, 0x20, 0x20, 0x20 };
       // case 0x06: return new byte[] { 0x86, 0x03, 0x86, 0xaa, 0x63, 0x03, 0x05, 0x0d, 0x00 };
        case 0x06: return new byte[] { 0x86, 0x03, 0x86, 0xaa, 0x63, 0x03, 0x0a, 0x05, 0x01 };
        case 0x07: return new byte[] { 0x86, 0x03, 0x87, 0xaa, 0x63, 0x06, 0x80, 0xfd, 0x00, 0x00, 0x80, 0xfd };
        case 0x08: return new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x03, 0x88, 0xaa, 0x63, 0x0e, 0x8c, 0x03, 0x5b, 0xfd, 0xcb, 0xfc, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f };

        case 0x0a: return new byte[] { 0x86, 0x03, 0x8a, 0xaa, 0x63, 0x08, 0x9c, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00}; // head 
        //case 0x0a: return new byte[] { 0x86, 0x03, 0x8a, 0xaa, 0x63, 0x0a, 0xb6, 0x01, 0xff, 0xff, 0xff, 0xff, 0x9b, 0x08, 0xa9, 0x05 };
        case 0x0b: return new byte[] { 0x86, 0x03, 0x8b, 0xaa, 0x63, 0x0c, 0x59, 0x31, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x9a, 0x50, 0x00, 0x00 };
        */
            default:
                    return null;
            }
        }

        bool SendResponse(byte[] data)
        {
            if (!Port.IsOpen)
            {
                return false;
            }

            Port.Write(data, 0, data.Count());

            return true;
        }

        private int GetBaudrate()
        {
            return 9600;
        }

        private static byte GetUInt8Random()
        {
            return (byte)new Random().Next(0, 255);
        }

        public string GetMenuString()
        {
            return "Carrier Direct (Request-Response protocol @ baudrate 9600)";
        }

        public void DeInit()
        {
            this.Port.Close();
        }
    }
}
